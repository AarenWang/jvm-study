
```
void invoke(Object obj, Object... args) { ... }
void invoke(String s, Object obj, Object... args) { ... }

invoke(null, 1);    // 调用第二个 invoke 方法
invoke(null, 1, 2); // 调用第二个 invoke 方法
invoke(null, new Object[]{1}); // 只有手动绕开可变长参数的语法糖，
                               // 才能调用第一个 invoke 方法

```

**方法重载**
 一个类中方法名称相同，但是参数签名不一样的方法叫方法重载，另外子类可以重载父类的非私有方法
 **重载方法** 调用识别步骤
 1. 第一阶段 不考虑基本类型自动装箱拆箱 以及可变长参数情况下选取重载方法
 2. 第二阶段 第一阶段没找到方法情况下 运行自动拆箱装箱 但不允许可变长参数情况下选取重载方法
 3. 第三阶段 第二阶段没找到方法情况下 运行自动拆箱装箱 允许可变长参数情况下选取重载方法
 4. 如果通一个阶段找到多个适配方法，那么允许自动拆箱装箱 允许可变长参数情况下 选择最为贴切的一个，而决定贴切程度的一个关键就是形式参数和类型和继承关系
 
 贴切的规则举例：
  1. 比如传入的参数为null,重载的方法形式参数类型分别为String和Object,则会选择参数为String的方法
  
  **方法重写**
   子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，如果是静态方法，则子类隐藏了父类方法，如果两个方法都不是静态，都不是私有方法，则子类**重写**了父类方法
   
  **方法重写是多态的最重要的体形形式** 


**静态绑定**

**动态绑定**



JVM方法调用五个指令
- invokestatic：用于调用静态方法。
- invokespecial：用于调用私有实例方法、构造器，及使用 super 关键字调用父类的实例方法或构造器，和所实...
- invokeinterface: 接口调用
- invoke


