两种执行方式
1. 字节码解释执行
2. JIT编译本地代码执行

JIT的有以下几种手段来优化JVM的性能
- 针对特定CPU型号的编译优化
- 减少查表次数
- 逃逸分析
- 寄存器分配 
- 热点代码编译好的机器码进行缓存
- 方法内联 

函数调用过程
1. 首先会有个执行栈，存储目前所有活跃的方法，以及它们的本地变量和参数
2. 当一个新的方法被调用了，一个新的栈帧会被加到栈顶，分配的本地变量和参数会存储在这个栈帧
3. 跳到目标方法代码执行
4. 方法返回的时候，本地方法和参数会被销毁，栈顶被移除
5. 返回原来地址执行
> 这就是通常说的函数调用的压栈和出栈过程，因此，函数调用需要有一定的时间开销和空间开销，当一个方法体不
>大，但又频繁被调用时，这个时间和空间开销会相对变得很大，变得非常不划算，同时降低了程序的性能

方法内联的原理
**方法内联就是把被调用方函数代码”复制”到调用方函数中，来减少因函数调用开销的技术**
```
private int add4(int x1, int x2, int x3, int x4) {  
        return add2(x1, x2) + add2(x3, x4);  
    }  

    private int add2(int x1, int x2) {  
        return x1 + x2;  
    }  
```

运行一段时间后JVM会把add2方法去掉，并把你的代码翻译成
```
private int add4(int x1, int x2, int x3, int x4) {  
        return x1 + x2 + x3 + x4;  
    } 
```
JVM会**自动的识别热点方法**，并对它们使用方法内联优化。那么一段代码需要执行多少次才会触发JIT优化呢？通常这个值由-XX:CompileThreshold参数进行设置：
1. 使用client编译器时，默认为1500
2. 使用server编译器时，默认为10000

一个方法就算被JVM标注成为热点方法，JVM仍然不一定会对它做方法内联优化。其中有个比较常见的原因就是这个方法体太大了，分为两种情况。

1. 如果方法是经常执行的，默认情况下，方法大小小于325字节的都会进行内联（可以通过-XX:MaxFreqInlineSize=N来设置这个大小）
2. 如果方法不是经常执行的，默认情况下，方法大小小于35字节才会进行内联（可以通过-XX:MaxInlineSize=N来设置这个大小）

如果想要知道方法被内联的情况，可以使用下面的JVM参数来配置
```
-XX:+PrintCompilation //在控制台打印编译过程信息
-XX:+UnlockDiagnosticVMOptions //解锁对JVM进行诊断的选项参数。默认是关闭的，开启后支持一些特定参数对JVM进行诊断
-XX:+PrintInlining //将内联方法打印出来
```